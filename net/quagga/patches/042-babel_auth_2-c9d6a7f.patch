commit c9d6a7f1d5ce1c704345869b9475ce2490c09155
Author: Denis Ovsienko <infrastation@yandex.ru>
Date:   Tue Jun 5 19:46:36 2012 +0400

    babeld: add packet authentication code
    
    This change introduces ESA (effective security association) structure,
    ESA, PC/TS and ANM helper functions and the functions, which handle
    authentication TLVs in transmitted and received packets.

diff --git a/babeld/babel_auth.c b/babeld/babel_auth.c
index ee06e8d..4e76aa3 100644
--- a/babeld/babel_auth.c
+++ b/babeld/babel_auth.c
@@ -26,6 +26,7 @@ THE SOFTWARE.
 #include "stream.h"
 #include "linklist.h"
 #include "cryptohash.h"
+#include "keychain.h"
 
 #include "babeld/babel_auth.h"
 #include "babeld/babel_interface.h"
@@ -47,6 +48,16 @@ struct babel_anm_item
   u_int32_t last_ts;
 };
 
+/* effective security association */
+struct babel_esa_item
+{
+  unsigned sort_order;
+  unsigned hash_algo;
+  u_int16_t key_id;
+  size_t key_len;
+  u_int8_t * key_secret;
+};
+
 /* local routing process variables */
 static u_int16_t auth_packetcounter;
 static u_int32_t auth_timestamp;
@@ -85,6 +96,583 @@ babel_anm_free (void * node)
   XFREE (MTYPE_BABEL_AUTH, node);
 }
 
+#ifdef HAVE_LIBGCRYPT
+/* Return an ANM record addressed with the given (source address, interface)
+ * pair, or NULL, if it is missing. */
+static struct babel_anm_item *
+babel_anm_lookup (const struct in6_addr *address, const struct interface *ifp)
+{
+  struct listnode *node;
+  struct babel_anm_item *anm;
+
+  for (ALL_LIST_ELEMENTS_RO (anmlist, node, anm))
+    if (IPV6_ADDR_SAME (anm->address.s6_addr, &address->s6_addr) && anm->ifp == ifp)
+      return anm;
+  return NULL;
+}
+
+/* Return an ANM record addressed with the given (source address, interface)
+ * pair. Create a new record, if a need is. */
+static struct babel_anm_item *
+babel_anm_get (const struct in6_addr *address, struct interface *ifp)
+{
+  struct babel_anm_item *anm;
+  char buffer[INET6_ADDRSTRLEN];
+
+  if (! (anm = babel_anm_lookup (address, ifp)))
+  {
+    anm = XCALLOC (MTYPE_BABEL_AUTH, sizeof (struct babel_anm_item));
+    IPV6_ADDR_COPY (&anm->address, address);
+    anm->ifp = ifp;
+    listnode_add (anmlist, anm);
+    if (UNLIKELY (BABEL_DEBUG_AUTH))
+    {
+      inet_ntop (AF_INET6, &anm->address, buffer, INET6_ADDRSTRLEN);
+      zlog_debug ("%s: adding memory record for %s", __func__, buffer);
+    }
+  }
+  return anm;
+}
+
+/* This periodic timer flushes expired records from authentic neighbors memory. */
+int
+babel_auth_do_housekeeping (struct thread *thread)
+{
+  struct listnode *node, *nextnode;
+  struct babel_anm_item *anm;
+  time_t now = quagga_time (NULL);
+  char buffer[INET6_ADDRSTRLEN];
+
+  for (ALL_LIST_ELEMENTS (anmlist, node, nextnode, anm))
+    if (anm->last_recv + anm_timeout < now)
+    {
+      if (UNLIKELY (BABEL_DEBUG_AUTH))
+      {
+        inet_ntop (AF_INET6, &anm->address, buffer, INET6_ADDRSTRLEN);
+        zlog_debug ("%s: memory record for %s has expired", __func__, buffer);
+      }
+      listnode_delete (anmlist, anm);
+      XFREE (MTYPE_BABEL_AUTH, anm);
+    }
+  thread_add_timer_msec (master, &babel_auth_do_housekeeping, NULL, 1000L);
+  return 0;
+}
+
+/* List hook function to deallocate an ESA record. */
+static void
+babel_esa_item_free (void * esa_key)
+{
+  XFREE (MTYPE_BABEL_AUTH, ((struct babel_esa_item *) esa_key)->key_secret);
+  XFREE (MTYPE_BABEL_AUTH, esa_key);
+}
+
+/* List hook function to compare two ESA record. */
+static int
+babel_esa_item_cmp (void *val1, void *val2)
+{
+  if (((struct babel_esa_item *)val1)->sort_order < ((struct babel_esa_item *)val2)->sort_order)
+    return -1;
+  if (((struct babel_esa_item *)val1)->sort_order > ((struct babel_esa_item *)val2)->sort_order)
+    return 1;
+  return 0;
+}
+
+/* Return 1, if the list contains a ESA record with the same attributes. */
+static unsigned char
+babel_esa_item_exists
+(
+  const struct list *esalist,
+  const unsigned new_hash_algo,
+  const u_int16_t new_key_id,
+  const size_t new_key_len,
+  const u_int8_t * new_key_secret
+)
+{
+  struct listnode *node;
+  struct babel_esa_item *esa;
+
+  for (ALL_LIST_ELEMENTS_RO (esalist, node, esa))
+    if
+    (
+      esa->hash_algo == new_hash_algo &&
+      esa->key_id == new_key_id &&
+      esa->key_len == new_key_len &&
+      ! memcmp (esa->key_secret, new_key_secret, new_key_len)
+    )
+      return 1;
+  return 0;
+}
+
+/* Build and return a list of ESAs from a given list of CSAs, a time reference
+ * and a filter function. The latter is typically keys_valid_for_send() or
+ * keys_valid_for_accept(). Take care of suppressing full ESA duplicates.
+ * Calling function is assumed to take care of deallocating the result with
+ * list_delete(). */
+static struct list *
+babel_esalist_new
+(
+  const struct list * csalist,
+  const time_t now,
+  struct list * (*keychain_filter_func) (const struct keychain *, const time_t)
+)
+{
+  struct list *esalist, *eligible;
+  struct listnode *node1, *node2;
+  struct babel_csa_item *csa;
+  struct keychain *keychain;
+  struct key *key;
+
+  esalist = list_new();
+  esalist->del = babel_esa_item_free;
+  esalist->cmp = babel_esa_item_cmp;
+  for (ALL_LIST_ELEMENTS_RO (csalist, node1, csa))
+  {
+    unsigned sort_order = 0;
+    keychain = keychain_lookup (csa->keychain_name);
+    if (! keychain)
+    {
+      debugf (BABEL_DEBUG_AUTH, "%s: keychain '%s' configured for %s does not exist", __func__,
+              csa->keychain_name, LOOKUP (hash_algo_str, csa->hash_algo));
+      continue;
+    }
+    debugf (BABEL_DEBUG_AUTH, "%s: found keychain '%s' with %u key(s) for %s", __func__,
+            csa->keychain_name, listcount (keychain->key), LOOKUP (hash_algo_str, csa->hash_algo));
+    eligible = keychain_filter_func (keychain, now);
+    for (ALL_LIST_ELEMENTS_RO (eligible, node2, key))
+    {
+      struct babel_esa_item *esa;
+      if (babel_esa_item_exists (esalist, csa->hash_algo, key->index % (UINT16_MAX + 1),
+          strlen (key->string), (u_int8_t *) key->string))
+      {
+        debugf (BABEL_DEBUG_AUTH, "%s: key ID %u is a full duplicate of another key", __func__,
+                key->index % (UINT16_MAX + 1));
+        continue;
+      }
+      esa = XCALLOC (MTYPE_BABEL_AUTH, sizeof (struct babel_esa_item));
+      esa->key_secret = (u_int8_t *) XSTRDUP (MTYPE_BABEL_AUTH, key->string);
+      esa->hash_algo = csa->hash_algo;
+      esa->key_id = key->index % (UINT16_MAX + 1);
+      esa->key_len = strlen (key->string);
+      esa->sort_order = sort_order;
+      listnode_add_sort (esalist, esa);
+      debugf (BABEL_DEBUG_AUTH, "%s: using key ID %d with sort order %u", __func__,
+              esa->key_id, sort_order);
+      sort_order++;
+    }
+    list_delete (eligible);
+  }
+  return esalist;
+}
+
+/* Return "stream getp" coordinate of PC followed by TS, if the first PC/TS TLV
+ * of the given packet exists and passes a constraint check against stored PC/TS
+ * values for the address of packet sender. Return -1 otherwise. */
+static int
+babel_auth_check_pcts (struct stream *packet, const u_int16_t stor_pc, const u_int32_t stor_ts)
+{
+  int ret = -1;
+  u_int8_t tlv_type;
+  u_int8_t tlv_length;
+  u_int16_t tlv_pc;
+  u_int32_t tlv_ts;
+
+  stream_set_getp (packet, 4);
+  while (STREAM_READABLE (packet))
+  {
+    tlv_type = stream_getc (packet);
+    if (tlv_type == MESSAGE_PAD1)
+      continue;
+    tlv_length = stream_getc (packet);
+    if (tlv_type != MESSAGE_PCTS)
+    {
+      stream_forward_getp (packet, tlv_length);
+      continue;
+    }
+    /* PC/TS TLV */
+    tlv_pc = stream_getw (packet);
+    tlv_ts = stream_getl (packet);
+    if (tlv_ts > stor_ts || (tlv_ts == stor_ts && tlv_pc > stor_pc))
+      ret = stream_get_getp(packet) - 6;
+    debugf (BABEL_DEBUG_AUTH, "%s: received PC/TS is (%u/%u), stored is (%u/%u), check %s", __func__,
+            tlv_pc, tlv_ts, stor_pc, stor_ts, ret == -1 ? "failed" : "OK");
+    /* only the 1st TLV matters */
+    return ret;
+  }
+  debugf (BABEL_DEBUG_AUTH, "%s: no PC/TS TLV in the packet, check failed", __func__);
+  return -1;
+}
+
+/* Make a copy of input packet, pad its HD TLVs and return the padded copy. */
+static struct stream *
+babel_auth_pad_packet (struct stream *packet, const unsigned char *addr6)
+{
+  struct stream *padded;
+  u_int8_t type, length;
+
+  padded = stream_dup (packet);
+  stream_reset (padded);
+  /* packet header is left unchanged */
+  stream_forward_endp (padded, 4);
+  stream_set_getp (packet, 4);
+  while (STREAM_READABLE (packet))
+  {
+    type = stream_getc (packet);
+    stream_forward_endp (padded, 1);
+    if (type == MESSAGE_PAD1)
+      continue;
+    length = stream_getc (packet);
+    stream_forward_endp (padded, 1);
+    if (type != MESSAGE_HD)
+      stream_forward_endp (padded, length);
+    else
+    {
+      stream_forward_endp (padded, 2);
+      debugf (BABEL_DEBUG_AUTH, "%s: padding %uB of digest at offset %zu", __func__,
+              length - 2, stream_get_endp (padded));
+      stream_put (padded, addr6, IPV6_MAX_BYTELEN);
+      stream_put (padded, NULL, length - IPV6_MAX_BYTELEN - 2);
+    }
+    stream_forward_getp (packet, length);
+  }
+  assert (stream_get_endp (packet) == stream_get_endp (padded));
+  return padded;
+}
+
+/* Scan the given packet for HD TLVs having Key ID and Length fields fitting
+ * the provided ESA. Return 1 if such TLVs exist and at least one has its Digest
+ * field matching a locally-computed HMAC digest of the padded version of the
+ * packet. Return 0 otherwise. */
+static int
+babel_auth_try_hd_tlvs
+(
+  struct stream *packet,      /* original packet                  */
+  struct stream *padded,      /* padded copy                      */
+  struct babel_esa_item *esa, /* current ESA                      */
+  unsigned *done              /* digests computed for this packet */
+)
+{
+  u_int8_t tlv_type;
+  u_int8_t tlv_length;
+  u_int16_t tlv_key_id;
+  u_int8_t local_digest[HASH_SIZE_MAX];
+  unsigned got_local_digest = 0;
+  char printbuf[2 * HASH_SIZE_MAX + 1];
+  unsigned i;
+
+  if (*done == BABEL_MAXDIGESTSIN)
+    return MSG_NG;
+  stream_set_getp (packet, 4);
+  while (STREAM_READABLE (packet))
+  {
+    tlv_type = stream_getc (packet);
+    if (tlv_type == MESSAGE_PAD1)
+      continue;
+    tlv_length = stream_getc (packet);
+    if (tlv_type != MESSAGE_HD || tlv_length != hash_digest_length[esa->hash_algo] + 2)
+    {
+      stream_forward_getp (packet, tlv_length);
+      continue;
+    }
+    tlv_key_id = stream_getw (packet);
+    if (tlv_key_id != esa->key_id)
+    {
+      stream_forward_getp (packet, tlv_length - 2);
+      continue;
+    }
+    /* fits scan criterias */
+    if (! got_local_digest)
+    {
+      /* Computation of local digest is lazy and happens only once for a given
+       * ESA. Number of computations done for a given packet is limited. */
+      unsigned hash_err = hash_make_hmac
+      (
+        esa->hash_algo,
+        stream_get_data (padded), stream_get_endp (padded), /* message */
+        esa->key_secret, esa->key_len,                      /* key     */
+        local_digest                                        /* result  */
+      );
+      if (hash_err)
+      {
+        zlog_err ("%s: hash function error %u", __func__, hash_err);
+        stats_internal_err++;
+        return MSG_NG;
+      }
+      (*done)++;
+      got_local_digest = 1;
+      if (UNLIKELY (debug & BABEL_DEBUG_AUTH))
+      {
+        for (i = 0; i + 2 < tlv_length; i++)
+          snprintf (printbuf + i * 2, 3, "%02X", local_digest[i]);
+        zlog_debug ("%s: local %s digest result #%u%s: %s", __func__,
+                    LOOKUP (hash_algo_str, esa->hash_algo), *done,
+                    (*done == BABEL_MAXDIGESTSIN ? " (last)" : ""), printbuf);
+      }
+    }
+    debugf (BABEL_DEBUG_AUTH, "%s: HD TLV with key ID %u, digest size %u",
+            __func__, tlv_key_id, tlv_length - 2);
+    /* OK to compare Digest field */
+    if (! memcmp (stream_get_data (packet) + stream_get_getp (packet), local_digest, tlv_length - 2))
+    {
+      debugf (BABEL_DEBUG_AUTH, "%s: TLV digest matches", __func__);
+      return MSG_OK;
+    }
+    if (UNLIKELY (debug & BABEL_DEBUG_AUTH))
+    {
+      for (i = 0; i + 2 < tlv_length; i++)
+        snprintf (printbuf + i * 2, 3, "%02X", stream_get_data (packet)[stream_get_getp (packet) + i]);
+      zlog_debug ("%s: TLV digest differs: %s", __func__, printbuf);
+    }
+    stream_forward_getp (packet, tlv_length - 2);
+  }
+  return MSG_NG;
+}
+
+/* Check given packet to be authentic, that is, to bear at least one PC/TS TLV,
+ * to have the first PC/TS TLV passed ANM check, to bear at least one HD TLV,
+ * to have at least one HD TLV passed HMAC check (done against the original
+ * packet after a padding procedure involving the IPv6 address of the sender).
+ * Take care of performing a HMAC procedure at most MaxDigestsIn times. */
+int babel_auth_check_packet
+(
+  struct interface *ifp,      /* inbound interface      */
+  const unsigned char *from,  /* IPv6 address of sender */
+  const unsigned char *input, /* received packet data   */
+  const u_int16_t packetlen
+)
+{
+  struct list *esalist;
+  struct listnode *node;
+  struct stream *packet, *padded;
+  struct babel_esa_item *esa;
+  struct babel_anm_item *anm;
+  struct babel_interface *babel_ifp = ifp->info;
+  time_t now;
+  int pcts_getp, result = MSG_NG;
+  u_int16_t neigh_pc = 0;
+  u_int32_t neigh_ts = 0;
+  unsigned digests_done = 0;
+
+  /* no CSAs => do nothing */
+  if (! listcount (babel_ifp->csalist))
+  {
+    stats_plain_recv++;
+    return MSG_OK;
+  }
+  debugf (BABEL_DEBUG_AUTH, "%s: packet length is %uB", __func__, packetlen);
+  /* original packet */
+  packet = stream_new (packetlen);
+  stream_put (packet, input, packetlen);
+  /* verify PC/TS before proceeding to expensive checks */
+  if (NULL != (anm = babel_anm_lookup ((const struct in6_addr *)from, ifp)))
+  {
+    neigh_pc = anm->last_pc;
+    neigh_ts = anm->last_ts;
+  }
+  if (-1 == (pcts_getp = babel_auth_check_pcts (packet, neigh_pc, neigh_ts)))
+  {
+    stream_free (packet);
+    stats_auth_recv_ng_pcts++;
+    return MSG_NG;
+  }
+  /* Pin' := Pin; pad Pin' */
+  padded = babel_auth_pad_packet (packet, from);
+  /* build ESA list */
+  now = quagga_time (NULL);
+  esalist = babel_esalist_new (babel_ifp->csalist, now, keys_valid_for_accept);
+  debugf (BABEL_DEBUG_AUTH, "%s: %u ESAs available", __func__, listcount (esalist));
+  if (! listcount (esalist))
+    zlog_warn ("interface %s has no valid keys", ifp->name);
+  /* try Pin HD TLVs against ESA list and Pin' */
+  for (ALL_LIST_ELEMENTS_RO (esalist, node, esa))
+    if (MSG_OK == (result = babel_auth_try_hd_tlvs (packet, padded, esa, &digests_done)))
+      break;
+  list_delete (esalist);
+  stream_free (padded);
+  debugf (BABEL_DEBUG_AUTH, "%s: authentication %s", __func__, result == MSG_OK ? "OK" : "failed");
+  if (result != MSG_OK)
+    stats_auth_recv_ng_hd++;
+  else
+  {
+    anm = babel_anm_get ((const struct in6_addr *)from, ifp); /* may create new */
+    anm->last_pc = stream_getw_from (packet, pcts_getp);
+    anm->last_ts = stream_getl_from (packet, pcts_getp + 2);
+    anm->last_recv = now;
+    stats_auth_recv_ok++;
+    debugf (BABEL_DEBUG_AUTH, "%s: updated neighbor PC/TS to (%u/%u)", __func__,
+            anm->last_pc, anm->last_ts);
+  }
+  stream_free (packet);
+  return result;
+}
+
+/* Return one of IPv6 addresses belonging to the given interface. Prefer a
+ * link-local one, then any IPv6 address, then fail. The address will be used
+ * to pad first 16 bytes of Digest field of HD TLVs. */
+static int
+babel_auth_got_source_address (const struct interface *ifp, unsigned char * addr)
+{
+  struct listnode *node;
+  struct connected *connected;
+  char buffer[INET6_ADDRSTRLEN];
+
+  FOR_ALL_INTERFACES_ADDRESSES (ifp, connected, node)
+    if
+    (
+      connected->address->family == AF_INET6 &&
+      connected->address->prefixlen == 64 &&
+      linklocal (connected->address->u.prefix6.s6_addr)
+    )
+    {
+      debugf (BABEL_DEBUG_AUTH, "%s: using link-local address %s", __func__,
+              inet_ntop (AF_INET6, &connected->address->u.prefix6, buffer, INET6_ADDRSTRLEN));
+      IPV6_ADDR_COPY (addr, connected->address->u.prefix6.s6_addr);
+      return 1;
+    }
+  FOR_ALL_INTERFACES_ADDRESSES (ifp, connected, node)
+    if (connected->address->family == AF_INET6)
+    {
+      debugf (BABEL_DEBUG_AUTH, "%s: using other address %s", __func__,
+              inet_ntop (AF_INET6, &connected->address->u.prefix6, buffer, INET6_ADDRSTRLEN));
+      IPV6_ADDR_COPY (addr, connected->address->u.prefix6.s6_addr);
+      return 1;
+    }
+  stats_internal_err++;
+  return 0;
+}
+
+/* Bump local routing process PC/TS variables before authenticating next packet. */
+static void
+babel_auth_bump_pcts (const time_t now)
+{
+  switch (ts_base)
+  {
+  case BABEL_TS_BASE_UNIX:
+    if (now > auth_timestamp)
+    {
+      auth_timestamp = now;
+      auth_packetcounter = 0;
+      return;
+    }
+    /* otherwise keep counting */
+  case BABEL_TS_BASE_ZERO:
+    if (++auth_packetcounter == 0)
+      ++auth_timestamp;
+    return;
+  }
+}
+/* Compute and append authentication TLVs to the given packet and return new
+ * packet length. New TLVs are one PC/TS TLV per packet and one HD TLV for each
+ * (but not more than MaxDigestsOut) ESA. HMAC procedure is performed on a copy
+ * of the packet after a padding procedure involving the IPv6 address of the
+ * sender. */
+int babel_auth_make_packet (struct interface *ifp, unsigned char * body, const u_int16_t body_len)
+{
+  struct list *esalist;
+  struct listnode *node;
+  struct babel_esa_item *esa;
+  struct stream *packet, *padded;
+  unsigned hd_done = 0;
+  size_t digest_offset[BABEL_MAXDIGESTSOUT];
+  int new_body_len;
+  char printbuf[2 * HASH_SIZE_MAX + 1];
+  unsigned i;
+  struct in6_addr sourceaddr;
+  struct babel_interface *babel_ifp = ifp->info;
+  time_t now;
+
+  /* no CSAs or no IPv6 addresses => do nothing */
+  if (! listcount (babel_ifp->csalist))
+  {
+    stats_plain_sent++;
+    return body_len;
+  }
+  if (! babel_auth_got_source_address (ifp, sourceaddr.s6_addr))
+  {
+    stats_internal_err++;
+    return body_len;
+  }
+  /* build ESA list */
+  now = quagga_time (NULL);
+  esalist = babel_esalist_new (babel_ifp->csalist, now, keys_valid_for_send);
+  debugf (BABEL_DEBUG_AUTH, "%s: %u ESAs available", __func__, listcount (esalist));
+  if (! listcount (esalist))
+    zlog_warn ("interface %s has no valid keys", ifp->name);
+  debugf (BABEL_DEBUG_AUTH, "%s: original body length is %uB", __func__, body_len);
+  /* packet header, original body, authentication TLVs */
+  packet = stream_new (4 + body_len + BABEL_MAXAUTHSPACE);
+  stream_putc (packet, RTPROT_BABEL);
+  stream_putc (packet, 2);
+  stream_putw (packet, 0); /* body length placeholder */
+  stream_put (packet, body, body_len);
+  /* append PC/TS TLV */
+  babel_auth_bump_pcts (now);
+  stream_putc (packet, MESSAGE_PCTS);
+  stream_putc (packet, 6);
+  stream_putw (packet, auth_packetcounter);
+  stream_putl (packet, auth_timestamp);
+  debugf (BABEL_DEBUG_AUTH, "%s: appended PC/TS TLV (%u/%u)", __func__,
+          auth_packetcounter, auth_timestamp);
+  /* HD: append up to MaxDigestsOut placeholder TLVs */
+  for (ALL_LIST_ELEMENTS_RO (esalist, node, esa))
+  {
+    debugf (BABEL_DEBUG_AUTH, "%s: padded HD TLV #%u (%s, ID %u) at offset %zu", __func__, hd_done,
+            LOOKUP (hash_algo_str, esa->hash_algo), esa->key_id, stream_get_endp (packet));
+    stream_putc (packet, MESSAGE_HD); /* type */
+    stream_putc (packet, 2 + hash_digest_length[esa->hash_algo]); /* length */
+    stream_putw (packet, esa->key_id); /* key ID */
+    digest_offset[hd_done] = stream_get_endp (packet);
+    stream_put (packet, &sourceaddr.s6_addr, IPV6_MAX_BYTELEN);
+    stream_put (packet, NULL, hash_digest_length[esa->hash_algo] - IPV6_MAX_BYTELEN);
+    /* FIXME: write source address */
+    if (++hd_done == BABEL_MAXDIGESTSOUT)
+      break;
+  }
+  /* time to fill in new body length */
+  new_body_len = stream_get_endp (packet) - 4;
+  debugf (BABEL_DEBUG_AUTH, "%s: authenticated body length is %uB", __func__, new_body_len);
+  stream_putw_at (packet, 2, new_body_len);
+  /* Pin' := Pin */
+  padded = stream_dup (packet);
+  /* fill in pending digests */
+  hd_done = 0;
+  for (ALL_LIST_ELEMENTS_RO (esalist, node, esa))
+  {
+    unsigned hash_err = hash_make_hmac
+    (
+      esa->hash_algo,
+      stream_get_data (padded), stream_get_endp (padded), /* message */
+      esa->key_secret, esa->key_len,                      /* key     */
+      stream_get_data (packet) + digest_offset[hd_done]   /* result  */
+    );
+    if (hash_err)
+    {
+      debugf (BABEL_DEBUG_AUTH, "%s: hash function error %u", __func__, hash_err);
+      list_delete (esalist);
+      stream_free (padded);
+      stream_free (packet);
+      stats_internal_err++;
+      return body_len;
+    }
+    if (UNLIKELY (debug & BABEL_DEBUG_AUTH))
+    {
+      for (i = 0; i < hash_digest_length[esa->hash_algo]; i++)
+        snprintf (printbuf + i * 2, 3, "%02X", stream_get_data (packet)[digest_offset[hd_done] + i]);
+      zlog_debug ("%s: digest #%u at offset %zu: %s", __func__,
+                  hd_done, digest_offset[hd_done], printbuf);
+    }
+    if (++hd_done == BABEL_MAXDIGESTSOUT)
+      break;
+  }
+  list_delete (esalist);
+  stream_free (padded);
+  /* append new TLVs to the original body */
+  memcpy (body + body_len, stream_get_data (packet) + 4 + body_len, new_body_len - body_len);
+  stream_free (packet);
+  stats_auth_sent++;
+  return new_body_len;
+}
+#endif /* HAVE_LIBGCRYPT */
+
 static void
 babel_auth_stats_reset()
 {
diff --git a/babeld/babel_auth.h b/babeld/babel_auth.h
index 6a2eb91..c5718c1 100644
--- a/babeld/babel_auth.h
+++ b/babeld/babel_auth.h
@@ -33,11 +33,21 @@ struct babel_csa_item
 #include "command.h"
 
 #ifdef HAVE_LIBGCRYPT
+#include "cryptohash.h"
+#include "if.h"
+#include "thread.h"
 #define BABEL_MAXDIGESTSOUT 8
 #define BABEL_MAXDIGESTSIN 4
+/* 1 PC/TS, maximum size/amount of HD TLVs, all including Type and Length fields */
+#define BABEL_MAXAUTHSPACE (8 + BABEL_MAXDIGESTSOUT * (4 + HASH_SIZE_MAX))
+extern int babel_auth_check_packet (struct interface *, const unsigned char *,
+                                    const unsigned char *, const u_int16_t);
+extern int babel_auth_make_packet (struct interface *, unsigned char *, const u_int16_t);
+extern int babel_auth_do_housekeeping (struct thread *);
 #else
 #define BABEL_MAXDIGESTSOUT 0
 #define BABEL_MAXDIGESTSIN 0
+#define BABEL_MAXAUTHSPACE 0
 #endif /* HAVE_LIBGCRYPT */
 
 extern void babel_auth_init (void);
diff --git a/babeld/babeld.c b/babeld/babeld.c
index 59f0bf8..56692e1 100644
--- a/babeld/babeld.c
+++ b/babeld/babeld.c
@@ -132,6 +132,9 @@ babel_create_routing_process (void)
     /* wait a little: zebra will announce interfaces, addresses, routes... */
     babel_routing_process->t_update =
     thread_add_timer_msec(master, &babel_init_routing_process, NULL, 200L);
+#ifdef HAVE_LIBGCRYPT
+    thread_add_timer_msec(master, &babel_auth_do_housekeeping, NULL, 1000L);
+#endif /* HAVE_LIBGCRYPT */
     return 0;
 
 fail:
diff --git a/babeld/message.c b/babeld/message.c
index 645fc77..5188c98 100644
--- a/babeld/message.c
+++ b/babeld/message.c
@@ -35,6 +35,7 @@ THE SOFTWARE.
 #include "message.h"
 #include "kernel.h"
 #include "babel_main.h"
+#include "babel_auth.h"
 
 static unsigned char packet_header[4] = {42, 2};
 
@@ -269,6 +270,13 @@ parse_packet(const unsigned char *from, struct interface *ifp,
         return;
     }
 
+#ifdef HAVE_LIBGCRYPT
+    /* Authenticate before find_neighbor() can create a new neighbor record,
+     * but only after packet structure is confirmed to be OK. */
+    if (MSG_OK != babel_auth_check_packet (ifp, from, packet, packetlen))
+        return;
+#endif /* HAVE_LIBGCRYPT */
+
     neigh = find_neighbour(from, ifp);
     if(neigh == NULL) {
         zlog_err("Couldn't allocate neighbour.");
@@ -570,6 +578,10 @@ flushbuf(struct interface *ifp)
             memcpy(&sin6.sin6_addr, protocol_group, 16);
             sin6.sin6_port = htons(protocol_port);
             sin6.sin6_scope_id = ifp->ifindex;
+#ifdef HAVE_LIBGCRYPT
+            babel_ifp->buffered = babel_auth_make_packet (ifp, babel_ifp->sendbuf, babel_ifp->buffered);
+            assert (babel_ifp->buffered <= babel_ifp->bufsize);
+#endif /* HAVE_LIBGCRYPT */
             DO_HTONS(packet_header + 2, babel_ifp->buffered);
             rc = babel_send(protocol_socket,
                             packet_header, sizeof(packet_header),
@@ -632,7 +644,7 @@ static void
 ensure_space(struct interface *ifp, int space)
 {
     babel_interface_nfo *babel_ifp = babel_get_if_nfo(ifp);
-    if(babel_ifp->bufsize - babel_ifp->buffered < space)
+    if(babel_ifp->bufsize - babel_ifp->buffered < space + BABEL_MAXAUTHSPACE)
         flushbuf(ifp);
 }
 
@@ -640,7 +652,7 @@ static void
 start_message(struct interface *ifp, int type, int len)
 {
   babel_interface_nfo *babel_ifp = babel_get_if_nfo(ifp);
-    if(babel_ifp->bufsize - babel_ifp->buffered < len + 2)
+    if(babel_ifp->bufsize - babel_ifp->buffered < len + 2 + BABEL_MAXAUTHSPACE)
         flushbuf(ifp);
     babel_ifp->sendbuf[babel_ifp->buffered++] = type;
     babel_ifp->sendbuf[babel_ifp->buffered++] = len;
@@ -685,7 +697,7 @@ start_unicast_message(struct neighbour *neigh, int type, int len)
 {
     if(unicast_neighbour) {
         if(neigh != unicast_neighbour ||
-           unicast_buffered + len + 2 >=
+           unicast_buffered + len + 2 + BABEL_MAXAUTHSPACE >=
            MIN(UNICAST_BUFSIZE, babel_get_if_nfo(neigh->ifp)->bufsize))
             flush_unicast(0);
     }
@@ -805,6 +817,10 @@ flush_unicast(int dofree)
         memcpy(&sin6.sin6_addr, unicast_neighbour->address, 16);
         sin6.sin6_port = htons(protocol_port);
         sin6.sin6_scope_id = unicast_neighbour->ifp->ifindex;
+#ifdef HAVE_LIBGCRYPT
+        unicast_buffered = babel_auth_make_packet (unicast_neighbour->ifp, unicast_buffer, unicast_buffered);
+        assert (unicast_buffered <= babel_get_if_nfo (unicast_neighbour->ifp)->bufsize);
+#endif /* HAVE_LIBGCRYPT */
         DO_HTONS(packet_header + 2, unicast_buffered);
         rc = babel_send(protocol_socket,
                         packet_header, sizeof(packet_header),
