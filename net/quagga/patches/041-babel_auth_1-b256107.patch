commit b2561079ea7f8f647ce5c94a90e535378eb5ca6e
Author: Denis Ovsienko <infrastation@yandex.ru>
Date:   Sun May 27 13:58:40 2012 +0400

    babeld: setup authentication infrastructure
    
    A debug mode, a memory type and two new files are added for Babel
    authentication code. Two new TLV types are listed (type 11 PC/TS and
    type 12 HD). CSA (configured security association) structures are
    introduced. Key chain management commands are enabled, "show babel
    interface" command is updated and authentication CLI commands added:
    
    * [no] debug babel authentication
    * show babel authentication stats
    * clear babel authentication stats
    * show babel authentication memory
    * clear babel authentication memory
    * [no] ts-base
    * [no] anm-timeout
    * [no] babel authentication

diff --git a/babeld/Makefile.am b/babeld/Makefile.am
index 8703de0..436ef5f 100644
--- a/babeld/Makefile.am
+++ b/babeld/Makefile.am
@@ -13,12 +13,12 @@ sbin_PROGRAMS = babeld
 libbabel_a_SOURCES = \
 	babel_zebra.c net.c kernel.c util.c source.c neighbour.c	\
 	route.c xroute.c message.c resend.c babel_interface.c babeld.c	\
-	babel_filter.c
+	babel_filter.c babel_auth.c
 
 noinst_HEADERS = \
 	babel_zebra.h net.h kernel.h util.h source.h neighbour.h	\
 	route.h xroute.h message.h resend.h babel_interface.h babeld.h	\
-	babel_filter.h babel_main.h
+	babel_filter.h babel_main.h babel_auth.h
 
 babeld_SOURCES = \
 	babel_main.c $(libbabel_a_SOURCES)
diff --git a/babeld/babel_auth.c b/babeld/babel_auth.c
new file mode 100644
index 0000000..ee06e8d
--- /dev/null
+++ b/babeld/babel_auth.c
@@ -0,0 +1,309 @@
+/*
+Copyright 2012 by Denis Ovsienko
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/
+
+#include <zebra.h>
+#include "log.h"
+#include "memory.h"
+#include "stream.h"
+#include "linklist.h"
+#include "cryptohash.h"
+
+#include "babeld/babel_auth.h"
+#include "babeld/babel_interface.h"
+#include "babeld/util.h"
+#include "babeld/message.h"
+
+#define BABEL_TS_BASE_ZERO        0
+#define BABEL_TS_BASE_UNIX        1
+#define BABEL_DEFAULT_TS_BASE     BABEL_TS_BASE_UNIX
+#define BABEL_DEFAULT_ANM_TIMEOUT 300
+
+/* authentic neighbors memory */
+struct babel_anm_item
+{
+  struct in6_addr address;
+  struct interface *ifp;
+  time_t last_recv;
+  u_int16_t last_pc;
+  u_int32_t last_ts;
+};
+
+/* local routing process variables */
+static u_int16_t auth_packetcounter;
+static u_int32_t auth_timestamp;
+static unsigned char ts_base;
+static u_int32_t anm_timeout;
+static struct list *anmlist;
+
+/* statistics */
+static unsigned long stats_plain_sent;
+static unsigned long stats_plain_recv;
+static unsigned long stats_auth_sent;
+static unsigned long stats_auth_recv_ng_pcts;
+static unsigned long stats_auth_recv_ng_hd;
+static unsigned long stats_auth_recv_ok;
+static unsigned long stats_internal_err;
+
+static const struct message ts_base_cli_str[] =
+{
+  { BABEL_TS_BASE_ZERO, "zero"      },
+  { BABEL_TS_BASE_UNIX, "unixtime"  },
+};
+static const size_t ts_base_cli_str_max = sizeof (ts_base_cli_str) / sizeof (struct message);
+
+static const struct message ts_base_str[] =
+{
+  { BABEL_TS_BASE_ZERO, "NVRAM-less PC wrap counter"  },
+  { BABEL_TS_BASE_UNIX, "UNIX time w/PC wrap counter" },
+};
+static const size_t ts_base_str_max = sizeof (ts_base_str) / sizeof (struct message);
+
+
+/* List hook function to deallocate an ANM record. */
+static void
+babel_anm_free (void * node)
+{
+  XFREE (MTYPE_BABEL_AUTH, node);
+}
+
+static void
+babel_auth_stats_reset()
+{
+  stats_plain_sent = 0;
+  stats_plain_recv = 0;
+  stats_auth_sent = 0;
+  stats_auth_recv_ng_pcts = 0;
+  stats_auth_recv_ng_hd = 0;
+  stats_auth_recv_ok = 0;
+  stats_internal_err = 0;
+}
+
+void
+show_babel_auth_parameters (struct vty *vty)
+{
+    vty_out(vty,
+            "libgcrypt enabled       = %s%s"
+            "HMAC-SHA256 enabled     = %s%s"
+            "HMAC-SHA384 enabled     = %s%s"
+            "HMAC-SHA512 enabled     = %s%s"
+            "HMAC-RMD160 enabled     = %s%s"
+            "HMAC-Whirlpool enabled  = %s%s"
+            "MaxDigestsIn            = %u%s"
+            "MaxDigestsOut           = %u%s"
+            "Timestamp               = %u%s"
+            "Packet counter          = %u%s"
+            "Timestamp base          = %s%s"
+            "Memory timeout          = %u%s",
+#ifdef HAVE_LIBGCRYPT
+            "yes", VTY_NEWLINE,
+#else
+            "no", VTY_NEWLINE,
+#endif /* HAVE_LIBGCRYPT */
+            hash_algo_enabled (HASH_HMAC_SHA256) ? "yes" : "no", VTY_NEWLINE,
+            hash_algo_enabled (HASH_HMAC_SHA384) ? "yes" : "no", VTY_NEWLINE,
+            hash_algo_enabled (HASH_HMAC_SHA512) ? "yes" : "no", VTY_NEWLINE,
+            hash_algo_enabled (HASH_HMAC_RMD160) ? "yes" : "no", VTY_NEWLINE,
+            hash_algo_enabled (HASH_HMAC_WHIRLPOOL) ? "yes" : "no", VTY_NEWLINE,
+            BABEL_MAXDIGESTSIN, VTY_NEWLINE,
+            BABEL_MAXDIGESTSOUT, VTY_NEWLINE,
+            auth_timestamp, VTY_NEWLINE,
+            auth_packetcounter, VTY_NEWLINE,
+            LOOKUP (ts_base_str, ts_base), VTY_NEWLINE,
+            anm_timeout, VTY_NEWLINE);
+}
+
+DEFUN (anm_timeout_val,
+       anm_timeout_val_cmd,
+       "anm-timeout <5-4294967295>",
+       "Authentic neighbors memory\n"
+       "Timeout in seconds")
+{
+  VTY_GET_INTEGER_RANGE ("timeout", anm_timeout, argv[0], 5, UINT32_MAX);
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_anm_timeout_val,
+       no_anm_timeout_val_cmd,
+       "no anm-timeout <5-4294967295>",
+       NO_STR
+       "Authentic neighbors memory\n"
+       "Timeout in seconds")
+{
+  anm_timeout = BABEL_DEFAULT_ANM_TIMEOUT;
+  return CMD_SUCCESS;
+}
+
+ALIAS (no_anm_timeout_val,
+       no_anm_timeout_cmd,
+       "no anm-timeout",
+       NO_STR
+       "Authentic neighbors memory\n"
+       "Timeout in seconds")
+
+DEFUN (ts_base_val,
+       ts_base_val_cmd,
+       "ts-base (zero|unixtime)",
+       "Packet timestamp base\n"
+       "NVRAM-less PC wrap counter\n"
+       "UNIX time w/PC wrap counter")
+{
+  if (! strcmp (argv[0], "zero"))
+    ts_base = BABEL_TS_BASE_ZERO;
+  else if (! strcmp (argv[0], "unixtime"))
+    ts_base = BABEL_TS_BASE_UNIX;
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_ts_base,
+       no_ts_base_val_cmd,
+       "no ts-base (zero|unixtime)",
+       NO_STR
+       "Packet timestamp base\n"
+       "NVRAM-less PC wrap counter\n"
+       "UNIX time w/PC wrap counter")
+{
+  ts_base = BABEL_DEFAULT_TS_BASE;
+  return CMD_SUCCESS;
+}
+
+ALIAS (no_ts_base,
+       no_ts_base_cmd,
+       "no ts-base",
+       NO_STR
+       "Packet timestamp base")
+
+DEFUN (show_babel_authentication_stats,
+       show_babel_authentication_stats_cmd,
+       "show babel authentication stats",
+       SHOW_STR
+       "Babel information\n"
+       "Packet authentication\n"
+       "Authentication statistics")
+{
+  const char *format_lu = "%-27s: %lu%s";
+
+  vty_out (vty, "== Packet authentication statistics ==%s", VTY_NEWLINE);
+  vty_out (vty, format_lu, "Plain Rx", stats_plain_recv, VTY_NEWLINE);
+  vty_out (vty, format_lu, "Plain Tx", stats_plain_sent, VTY_NEWLINE);
+  vty_out (vty, format_lu, "Authenticated Tx", stats_auth_sent, VTY_NEWLINE);
+  vty_out (vty, format_lu, "Authenticated Rx OK", stats_auth_recv_ok, VTY_NEWLINE);
+  vty_out (vty, format_lu, "Authenticated Rx bad PC/TS", stats_auth_recv_ng_pcts, VTY_NEWLINE);
+  vty_out (vty, format_lu, "Authenticated Rx bad HD", stats_auth_recv_ng_hd, VTY_NEWLINE);
+  vty_out (vty, format_lu, "Internal errors", stats_internal_err, VTY_NEWLINE);
+  vty_out (vty, format_lu, "ANM records", listcount (anmlist), VTY_NEWLINE);
+  return CMD_SUCCESS;
+}
+
+DEFUN (clear_babel_authentication_stats,
+       clear_babel_authentication_stats_cmd,
+       "clear babel authentication stats",
+       CLEAR_STR
+       "Babel information\n"
+       "Packet authentication\n"
+       "Authentication statistics")
+{
+  babel_auth_stats_reset();
+  return CMD_SUCCESS;
+}
+
+DEFUN (show_babel_authentication_memory,
+       show_babel_authentication_memory_cmd,
+       "show babel authentication memory",
+       SHOW_STR
+       "Babel information\n"
+       "Packet authentication\n"
+       "Authentic neighbors memory")
+{
+  struct listnode *node;
+  struct babel_anm_item *anm;
+  char buffer[INET6_ADDRSTRLEN];
+  time_t now = quagga_time (NULL);
+  const char *format_s = "%46s %10s %10s %5s %10s%s";
+  const char *format_u = "%46s %10s %10u %5u %10u%s";
+
+  vty_out (vty, "ANM timeout: %u seconds, ANM records: %u%s", anm_timeout,
+           listcount (anmlist), VTY_NEWLINE);
+  vty_out (vty, format_s, "Source address", "Interface", "TS", "PC", "Age", VTY_NEWLINE);
+  for (ALL_LIST_ELEMENTS_RO (anmlist, node, anm))
+  {
+    inet_ntop (AF_INET6, &anm->address, buffer, INET6_ADDRSTRLEN);
+    vty_out (vty, format_u, buffer, anm->ifp->name, anm->last_ts, anm->last_pc,
+             now - anm->last_recv, VTY_NEWLINE);
+  }
+  return CMD_SUCCESS;
+}
+
+DEFUN (clear_babel_authentication_memory,
+       clear_babel_authentication_memory_cmd,
+       "clear babel authentication memory",
+       CLEAR_STR
+       "Babel information\n"
+       "Packet authentication\n"
+       "Authentic neighbors memory")
+{
+  list_delete_all_node (anmlist);
+  return CMD_SUCCESS;
+}
+
+int
+babel_auth_config_write (struct vty *vty)
+{
+  int lines = 0;
+
+  if (anm_timeout != BABEL_DEFAULT_ANM_TIMEOUT)
+  {
+      vty_out (vty, " anm-timeout %u%s", anm_timeout, VTY_NEWLINE);
+      lines++;
+  }
+  if (ts_base != BABEL_DEFAULT_TS_BASE)
+  {
+      vty_out (vty, " ts-base %s%s", LOOKUP (ts_base_cli_str, ts_base), VTY_NEWLINE);
+      lines++;
+  }
+  return lines;
+}
+
+void
+babel_auth_init()
+{
+  if (hash_library_init())
+    exit (1);
+  anmlist = list_new();
+  anmlist->del = babel_anm_free;
+  babel_auth_stats_reset();
+  auth_packetcounter = 0;
+  auth_timestamp = 0;
+  anm_timeout = BABEL_DEFAULT_ANM_TIMEOUT;
+  ts_base = BABEL_DEFAULT_TS_BASE;
+  install_element (BABEL_NODE, &anm_timeout_val_cmd);
+  install_element (BABEL_NODE, &no_anm_timeout_val_cmd);
+  install_element (BABEL_NODE, &no_anm_timeout_cmd);
+  install_element (BABEL_NODE, &ts_base_val_cmd);
+  install_element (BABEL_NODE, &no_ts_base_val_cmd);
+  install_element (BABEL_NODE, &no_ts_base_cmd);
+  install_element (VIEW_NODE, &show_babel_authentication_stats_cmd);
+  install_element (VIEW_NODE, &show_babel_authentication_memory_cmd);
+  install_element (ENABLE_NODE, &show_babel_authentication_stats_cmd);
+  install_element (ENABLE_NODE, &show_babel_authentication_memory_cmd);
+  install_element (ENABLE_NODE, &clear_babel_authentication_stats_cmd);
+  install_element (ENABLE_NODE, &clear_babel_authentication_memory_cmd);
+}
diff --git a/babeld/babel_auth.h b/babeld/babel_auth.h
new file mode 100644
index 0000000..6a2eb91
--- /dev/null
+++ b/babeld/babel_auth.h
@@ -0,0 +1,47 @@
+/*
+Copyright 2012 by Denis Ovsienko
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/
+
+#ifndef BABEL_AUTH_H
+#define BABEL_AUTH_H
+
+/* configured security association */
+struct babel_csa_item
+{
+  unsigned hash_algo;
+  char * keychain_name;
+};
+
+#include "command.h"
+
+#ifdef HAVE_LIBGCRYPT
+#define BABEL_MAXDIGESTSOUT 8
+#define BABEL_MAXDIGESTSIN 4
+#else
+#define BABEL_MAXDIGESTSOUT 0
+#define BABEL_MAXDIGESTSIN 0
+#endif /* HAVE_LIBGCRYPT */
+
+extern void babel_auth_init (void);
+extern int babel_auth_config_write (struct vty *);
+extern void show_babel_auth_parameters (struct vty *);
+
+#endif /* BABEL_AUTH_H */
diff --git a/babeld/babel_interface.c b/babeld/babel_interface.c
index d111a2b..04df1c8 100644
--- a/babeld/babel_interface.c
+++ b/babeld/babel_interface.c
@@ -27,6 +27,8 @@ THE SOFTWARE.
 #include "prefix.h"
 #include "vector.h"
 #include "distribute.h"
+#include "cryptohash.h"
+#include "keychain.h"
 
 #include "babel_main.h"
 #include "util.h"
@@ -38,6 +40,7 @@ THE SOFTWARE.
 #include "neighbour.h"
 #include "route.h"
 #include "xroute.h"
+#include "babel_auth.h"
 
 
 #define IS_ENABLE(ifp) (babel_enable_if_lookup(ifp->name) >= 0)
@@ -462,6 +465,108 @@ DEFUN (babel_set_update_interval,
     return CMD_SUCCESS;
 }
 
+/* Return matching security association or NULL of none was found. */
+static struct babel_csa_item *
+babel_csalist_lookup (const struct list *csalist, const unsigned hash_algo, const char *keychain_name)
+{
+  struct listnode *node;
+  struct babel_csa_item *csa;
+
+  for (ALL_LIST_ELEMENTS_RO (csalist, node, csa))
+    if (csa->hash_algo == hash_algo && ! strcmp (csa->keychain_name, keychain_name))
+      return csa;
+  return NULL;
+}
+
+/* Callback function to deallocate a CSA structure stored in a list. */
+static void
+babel_csa_item_free (void * node)
+{
+    XFREE (MTYPE_BABEL_AUTH, ((struct babel_csa_item *)node)->keychain_name);
+    XFREE (MTYPE_BABEL_AUTH, node);
+}
+
+DEFUN (babel_authentication_mode_keychain,
+       babel_authentication_mode_keychain_cmd,
+       "babel authentication mode (sha256|sha384|sha512|rmd160|whirlpool) key-chain LINE",
+       "Babel interface commands\n"
+       "Packet authentication\n"
+       "Authentication mode\n"
+       "HMAC-SHA-256\n"
+       "HMAC-SHA-384\n"
+       "HMAC-SHA-512\n"
+       "HMAC-RIPEMD-160\n"
+       "HMAC-Whirlpool\n"
+       "Authentication key-chain\n"
+       "name of key-chain\n")
+{
+    struct interface *ifp = vty->index;
+    babel_interface_nfo *babel_ifp = babel_get_if_nfo (ifp);
+    unsigned hash_algo = hash_algo_byname (argv[0]);
+    struct babel_csa_item *csa = babel_csalist_lookup (babel_ifp->csalist, hash_algo, argv[1]);
+
+    if (csa)
+    {
+        vty_out (vty, "Duplicate security association for this interface!%s", VTY_NEWLINE);
+        return CMD_WARNING;
+    }
+    if (! hash_algo_enabled (hash_algo))
+    {
+        vty_out (vty, "Algorithm '%s' is not enabled in this build%s", argv[0], VTY_NEWLINE);
+        return CMD_ERR_NO_MATCH;
+    }
+    csa = XCALLOC (MTYPE_BABEL_AUTH, sizeof (struct babel_csa_item));
+    csa->hash_algo = hash_algo;
+    csa->keychain_name = XSTRDUP (MTYPE_BABEL_AUTH, argv[1]);
+    listnode_add (babel_ifp->csalist, csa);
+    return CMD_SUCCESS;
+}
+
+DEFUN (no_babel_authentication_mode_keychain,
+       no_babel_authentication_mode_keychain_cmd,
+       "no babel authentication mode (sha256|sha384|sha512|rmd160|whirlpool) key-chain LINE",
+       NO_STR
+       "Babel interface commands\n"
+       "Packet authentication\n"
+       "Authentication mode\n"
+       "HMAC-SHA-256\n"
+       "HMAC-SHA-384\n"
+       "HMAC-SHA-512\n"
+       "HMAC-RIPEMD-160\n"
+       "HMAC-Whirlpool\n"
+       "Authentication key-chain\n"
+       "name of key-chain\n")
+{
+    struct interface *ifp = vty->index;
+    babel_interface_nfo *babel_ifp = babel_get_if_nfo (ifp);
+    unsigned hash_algo = hash_algo_byname (argv[0]);
+    struct babel_csa_item *csa = babel_csalist_lookup (babel_ifp->csalist, hash_algo, argv[1]);
+
+    if (! csa)
+    {
+        vty_out (vty, "No such security association configured for this interface!%s", VTY_NEWLINE);
+        return CMD_WARNING;
+    }
+    listnode_delete (babel_ifp->csalist, csa); /* does not call "del" hook */
+    XFREE (MTYPE_BABEL_AUTH, csa->keychain_name);
+    XFREE (MTYPE_BABEL_AUTH, csa);
+    return CMD_SUCCESS;
+}
+
+DEFUN (no_babel_authentication,
+       no_babel_authentication_cmd,
+       "no babel authentication",
+       NO_STR
+       "Babel interface commands\n"
+       "Packet authentication\n")
+{
+    struct interface *ifp = vty->index;
+    babel_interface_nfo *babel_ifp = babel_get_if_nfo (ifp);
+
+    list_delete_all_node (babel_ifp->csalist); /* calls "del" hook */
+    return CMD_SUCCESS;
+}
+
 /* This should be no more than half the hello interval, so that hellos
    aren't sent late.  The result is in milliseconds. */
 unsigned
@@ -672,6 +777,9 @@ show_babel_interface_sub (struct vty *vty, struct interface *ifp)
 {
   int is_up;
   babel_interface_nfo *babel_ifp;
+  struct listnode *node;
+  struct babel_csa_item *csa;
+  time_t now = quagga_time (NULL);
 
   vty_out (vty, "%s is %s%s", ifp->name,
     ((is_up = if_is_operative(ifp)) ? "up" : "down"), VTY_NEWLINE);
@@ -696,6 +804,27 @@ show_babel_interface_sub (struct vty *vty, struct interface *ifp)
            CHECK_FLAG (babel_ifp->flags, BABEL_IF_SPLIT_HORIZON) ? "On" : "Off", VTY_NEWLINE);
   vty_out (vty, "  Hello interval is %u ms%s", babel_ifp->hello_interval, VTY_NEWLINE);
   vty_out (vty, "  Update interval is %u ms%s", babel_ifp->update_interval, VTY_NEWLINE);
+  vty_out (vty, "  Packet authentication is %s%s", listcount (babel_ifp->csalist) ?
+           "enabled" : "disabled", VTY_NEWLINE);
+  for (ALL_LIST_ELEMENTS_RO (babel_ifp->csalist, node, csa))
+  {
+    struct keychain *keychain = keychain_lookup (csa->keychain_name);
+    struct list *eligible;
+
+    vty_out (vty, "    Algorithm %s key-chain \"%s\" (",
+             LOOKUP (hash_algo_str, csa->hash_algo), csa->keychain_name);
+    if (! keychain)
+    {
+      vty_out (vty, "does not exist)%s", VTY_NEWLINE);
+      continue;
+    }
+    eligible = keys_valid_for_send (keychain, now);
+    vty_out (vty, "keys: %u/%u OK for Tx, ", listcount (eligible), listcount (keychain->key));
+    list_delete (eligible);
+    eligible = keys_valid_for_accept (keychain, now);
+    vty_out (vty, "%u/%u OK for Rx)%s", listcount (eligible), listcount (keychain->key), VTY_NEWLINE);
+    list_delete (eligible);
+  }
 }
 
 DEFUN (show_babel_interface,
@@ -861,6 +990,8 @@ DEFUN (show_babel_parameters,
     show_babel_main_configuration(vty);
     vty_out(vty, "    -- distribution lists --%s", VTY_NEWLINE);
     config_show_distribute(vty);
+    vty_out(vty, "    -- packet authentication --%s", VTY_NEWLINE);
+    show_babel_auth_parameters(vty);
 
     return CMD_SUCCESS;
 }
@@ -892,6 +1023,10 @@ babel_if_init ()
     install_element(INTERFACE_NODE, &babel_set_hello_interval_cmd);
     install_element(INTERFACE_NODE, &babel_set_update_interval_cmd);
 
+    install_element(INTERFACE_NODE, &babel_authentication_mode_keychain_cmd);
+    install_element(INTERFACE_NODE, &no_babel_authentication_mode_keychain_cmd);
+    install_element(INTERFACE_NODE, &no_babel_authentication_cmd);
+
     /* "show babel ..." commands */
     install_element(VIEW_NODE, &show_babel_interface_cmd);
     install_element(ENABLE_NODE, &show_babel_interface_cmd);
@@ -932,6 +1067,8 @@ interface_config_write (struct vty *vty)
     struct listnode *node;
     struct interface *ifp;
     int write = 0;
+    struct listnode *csanode;
+    struct babel_csa_item *csa;
 
     for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp)) {
         vty_out (vty, "interface %s%s", ifp->name,
@@ -961,6 +1098,12 @@ interface_config_write (struct vty *vty)
             vty_out (vty, " babel update-interval %u%s", babel_ifp->update_interval, VTY_NEWLINE);
             write++;
         }
+        for (ALL_LIST_ELEMENTS_RO (babel_ifp->csalist, csanode, csa))
+        {
+            vty_out (vty, " babel authentication mode %s key-chain %s%s",
+                     LOOKUP (hash_algo_cli_str, csa->hash_algo), csa->keychain_name, VTY_NEWLINE);
+            write++;
+        }
         vty_out (vty, "!%s", VTY_NEWLINE);
         write++;
     }
@@ -1003,6 +1146,8 @@ babel_interface_allocate (void)
     babel_ifp->update_interval = BABEL_DEFAULT_UPDATE_INTERVAL;
     babel_ifp->channel = BABEL_IF_CHANNEL_INTERFERING;
     babel_set_wired_internal(babel_ifp, 0);
+    babel_ifp->csalist = list_new();
+    babel_ifp->csalist->del = babel_csa_item_free;
 
     return babel_ifp;
 }
@@ -1010,5 +1155,6 @@ babel_interface_allocate (void)
 static void
 babel_interface_free (babel_interface_nfo *babel_ifp)
 {
+    list_delete (babel_ifp->csalist);
     XFREE(MTYPE_BABEL_IF, babel_ifp);
 }
diff --git a/babeld/babel_interface.h b/babeld/babel_interface.h
index 2363437..c7d80a6 100644
--- a/babeld/babel_interface.h
+++ b/babeld/babel_interface.h
@@ -67,6 +67,7 @@ struct babel_interface {
 #define BABEL_FILTER_MAX 2
     struct access_list *list[BABEL_FILTER_MAX];               /* Access-list. */
     struct prefix_list *prefix[BABEL_FILTER_MAX];             /* Prefix-list. */
+    struct list *csalist;                                     /* list of CSAs */
 };
 
 typedef struct babel_interface babel_interface_nfo;
@@ -112,7 +113,6 @@ struct buffered_update {
     unsigned char pad[3];
 };
 
-
 /* init function */
 void babel_if_init(void);
 
diff --git a/babeld/babel_main.c b/babeld/babel_main.c
index bf84a5f..0dcf5e5 100644
--- a/babeld/babel_main.c
+++ b/babeld/babel_main.c
@@ -32,6 +32,7 @@ THE SOFTWARE.
 #include "command.h"
 #include "vty.h"
 #include "memory.h"
+#include "keychain.h"
 
 #include "babel_main.h"
 #include "babeld.h"
@@ -44,6 +45,7 @@ THE SOFTWARE.
 #include "message.h"
 #include "resend.h"
 #include "babel_zebra.h"
+#include "babel_auth.h"
 
 
 static void babel_init (int argc, char **argv);
@@ -238,6 +240,7 @@ babel_init(int argc, char **argv)
     cmd_init (1);
     vty_init (master);
     memory_init ();
+    keychain_init();
 
     resend_delay = BABEL_DEFAULT_RESEND_DELAY;
 
@@ -256,6 +259,7 @@ babel_init(int argc, char **argv)
 
     /* init some quagga's dependencies, and babeld's commands */
     babeld_quagga_init();
+    babel_auth_init();
     /* init zebra client's structure and it's commands */
     /* this replace kernel_setup && kernel_setup_socket */
     babelz_zebra_init ();
diff --git a/babeld/babel_zebra.c b/babeld/babel_zebra.c
index 222d60f..6789708 100644
--- a/babeld/babel_zebra.c
+++ b/babeld/babel_zebra.c
@@ -51,6 +51,7 @@ static struct {
     {BABEL_DEBUG_TIMEOUT, 1, "timeout"},
     {BABEL_DEBUG_IF,      1, "interface"},
     {BABEL_DEBUG_ROUTE,   1, "route"},
+    {BABEL_DEBUG_AUTH,    1, "authentication"},
     {BABEL_DEBUG_ALL,     1, "all"},
     {0, 0, NULL}
 };
@@ -222,7 +223,7 @@ DEFUN (no_babel_redistribute_type,
 /* [Babel Command] */
 DEFUN (debug_babel,
        debug_babel_cmd,
-       "debug babel (common|kernel|filter|timeout|interface|route|all)",
+       "debug babel (common|kernel|filter|timeout|interface|route|authentication|all)",
        "Enable debug messages for specific or all part.\n"
        "Babel information\n"
        "Common messages (default)\n"
@@ -231,6 +232,7 @@ DEFUN (debug_babel,
        "Timeout messages\n"
        "Interface messages\n"
        "Route messages\n"
+       "Packet authentication\n"
        "All messages\n")
 {
     int i;
@@ -251,7 +253,7 @@ DEFUN (debug_babel,
 /* [Babel Command] */
 DEFUN (no_debug_babel,
        no_debug_babel_cmd,
-       "no debug babel (common|kernel|filter|timeout|interface|route|all)",
+       "no debug babel (common|kernel|filter|timeout|interface|route|authentication|all)",
        NO_STR
        "Disable debug messages for specific or all part.\n"
        "Babel information\n"
@@ -261,6 +263,7 @@ DEFUN (no_debug_babel,
        "Timeout messages\n"
        "Interface messages\n"
        "Route messages\n"
+       "Packet authentication\n"
        "All messages\n")
 {
     int i;
diff --git a/babeld/babeld.c b/babeld/babeld.c
index 5f8e5a8..59f0bf8 100644
--- a/babeld/babeld.c
+++ b/babeld/babeld.c
@@ -43,6 +43,7 @@ THE SOFTWARE.
 #include "resend.h"
 #include "babel_filter.h"
 #include "babel_zebra.h"
+#include "babel_auth.h"
 
 
 static int babel_init_routing_process(struct thread *thread);
@@ -90,6 +91,7 @@ babel_config_write (struct vty *vty)
         vty_out (vty, " babel resend-delay %u%s", resend_delay, VTY_NEWLINE);
         lines++;
     }
+    lines += babel_auth_config_write (vty);
     /* list enabled interfaces */
     lines = 1 + babel_enable_if_config_write (vty);
     /* list redistributed protocols */
diff --git a/babeld/message.c b/babeld/message.c
index 27108ed..645fc77 100644
--- a/babeld/message.c
+++ b/babeld/message.c
@@ -65,6 +65,8 @@ static const unsigned char tlv_min_length[MESSAGE_MAX + 1] =
     [ MESSAGE_UPDATE     ] = 10,
     [ MESSAGE_REQUEST    ] =  2,
     [ MESSAGE_MH_REQUEST ] = 14,
+    [ MESSAGE_PCTS       ] =  6,
+    [ MESSAGE_HD         ] = 18,
 };
 
 /* Parse a network prefix, encoded in the somewhat baroque compressed
@@ -230,6 +232,7 @@ babel_packet_examin(const unsigned char *packet, int packetlen)
         case MESSAGE_ACK:
         case MESSAGE_HELLO:
         case MESSAGE_ROUTER_ID:
+        case MESSAGE_PCTS:
           if (len == tlv_min_length[type])
             break;
           debugf(BABEL_DEBUG_COMMON,"Oversized %u TLV", type);
@@ -503,6 +506,8 @@ parse_packet(const unsigned char *from, struct interface *ifp,
                    format_eui64(message + 8), seqno);
             handle_request(neigh, prefix, plen, message[6],
                            seqno, message + 8);
+        } else if(type == MESSAGE_PCTS) {
+        } else if(type == MESSAGE_HD) {
         } else {
             debugf(BABEL_DEBUG_COMMON,"Received unknown packet type %d from %s on %s.",
                    type, format_address(from), ifp->name);
diff --git a/babeld/message.h b/babeld/message.h
index 915cf89..f25c0a4 100644
--- a/babeld/message.h
+++ b/babeld/message.h
@@ -41,7 +41,9 @@ THE SOFTWARE.
 #define MESSAGE_UPDATE 8
 #define MESSAGE_REQUEST 9
 #define MESSAGE_MH_REQUEST 10
-#define MESSAGE_MAX 10
+#define MESSAGE_PCTS 11
+#define MESSAGE_HD 12
+#define MESSAGE_MAX 12
 
 
 extern unsigned short myseqno;
diff --git a/babeld/util.h b/babeld/util.h
index 7cbf626..da54448 100644
--- a/babeld/util.h
+++ b/babeld/util.h
@@ -132,6 +132,7 @@ static inline void debugf(int level, const char *format, ...) { return; }
 #define BABEL_DEBUG_TIMEOUT     (1 << 3)
 #define BABEL_DEBUG_IF          (1 << 4)
 #define BABEL_DEBUG_ROUTE       (1 << 5)
+#define BABEL_DEBUG_AUTH        (1 << 6)
 #define BABEL_DEBUG_ALL         (0xFFFF)
 
 #if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
diff --git a/doc/babeld.texi b/doc/babeld.texi
index c261049..82066e9 100644
--- a/doc/babeld.texi
+++ b/doc/babeld.texi
@@ -80,12 +80,67 @@ to fairly high values on links with little packet loss.  The default
 is 20000@dmn{ms}.
 @end deffn
 
+@deffn {Interface Command} {babel authentication mode @var{authmode} key-chain @var{keychain}} {}
+@deffnx {Interface Command} {no babel authentication mode @var{authmode} key-chain @var{keychain}} {}
+Manage (add or remove) configured security associations (CSAs) for the current
+interface. There may be multiple CSAs configured for an interface.
+@var{keychain} stands for a name of a standard key chain. @var{authmode} stands
+for a HMAC algorithm based on one of the following hash functions of choice.
+A HMAC algorithm uses a secret key and a compound PC/TS number to produce one
+or more digests for each protocol packet.
+@itemize @bullet
+@item
+@code{sha256/sha384/sha512}:
+SHA-256, SHA-384 and SHA-512 hash functions respectively, which belong to SHA-2
+family of hash functions and produce a digest 256-bit, 384-bit and 512-bit long
+respectively.
+@item
+@code{rmd160}:
+RIPEMD-160 hash function, which produces a digest 160-bit long.
+@item
+@code{whirlpool}:
+Whirlpool hash function, which produces a digest 512-bit long.
+@end itemize
+All of the hash functions listed above are considered relatively strong at the
+time of this writing and require Quagga to be built with gcrypt library.
+@ref{The Configure script and its options}
+@end deffn
+
+@deffn {Interface Command} {no babel authentication} {}
+Remove all configured security associations (CSAs) from the current interface.
+@end deffn
+
 @deffn {Babel Command} {babel resend-delay <20-655340>}
 Specifies the time in milliseconds after which an ``important''
 request or update will be resent.  The default is 2000@dmn{ms}.  You
 probably don't want to tweak this value.
 @end deffn
 
+@deffn {Babel Command} {anm-timeout <5-4294967295>} {}
+@deffnx {Babel Command} {no anm-timeout [<5-4294967295>]} {}
+Specifies the time in seconds, for which a record about a formerly active
+authentic Babel neighbor will be retained in ANM (authentic neighbor memory).
+The default is 300@dmn{s}.
+@end deffn
+
+@deffn {Babel Command} {ts-base (zero|unixtime)} {}
+@deffnx {Babel Command} {no ts-base [(zero|unixtime)]} {}
+Controls setting of TS (Timestamp) variable of local routing process. TS is
+put into a PC/TS TLV of every packet being authenticated to prevent replay
+attacks.
+@itemize @bullet
+@item
+@code{unixtime}:
+Configures UNIX time as TS base: makes TS be greater or equal to the current
+UNIX time, which allows for unique PC/TS pairs for the deployed lifetime of
+a Babel router. This is the default mode in Quagga.
+@item
+@code{zero}
+Configures 0 as TS base: TS starts at value 0 and increment each time the
+Packet Counter wraps.
+@end itemize
+@end deffn
+
 @node Babel redistribution, Show Babel information, Babel configuration, Babel
 @section Babel redistribution
 
@@ -105,6 +160,24 @@ These commands dump various parts of @command{babeld}'s internal
 state.  They are mostly useful for troubleshooting.
 @end deffn
 
+@deffn {Command} {show babel authentication stats} {}
+@deffnx {Command} {clear babel authentication stats} {}
+There are some statistics built during operation of packet authentication
+extension. These commands display and reset those statistics.
+@end deffn
+
+@deffn {Command} {show babel authentication memory} {}
+@deffnx {Command} {clear babel authentication memory} {}
+Babel packet authentication extension maintains an internal table known as
+"authentic neighbors memory" (ANM), which is used to protect against packet
+replay attacks. ANM retains PC/TS values of authentic Babel neighbors, both
+current and formerly active, for "ANM timeout" period of time.
+
+The commands display and reset ANM records. Resetting ANM records may be
+necessary to avoid a "quarantine period" for restarted Babel neighbors
+operating in "NVRAM-less wrap counter" TS mode.
+@end deffn
+
 @node Babel debugging commands,  , Show Babel information, Babel
 @section Babel debugging commands
 
@@ -112,7 +185,7 @@ state.  They are mostly useful for troubleshooting.
 @deffnx {Babel Command} {no debug babel @var{kind}} {}
 Enable or disable debugging messages of a given kind.  @var{kind} can
 be one of @samp{common}, @samp{kernel}, @samp{filter}, @samp{timeout},
-@samp{interface}, @samp{route} or @samp{all}.  Note that if you have
+@samp{interface}, @samp{route}, @samp{authentication} or @samp{all}. Note that if you have
 compiled with the NO_DEBUG flag, then these commands aren't available.
 @end deffn
 
diff --git a/lib/memtypes.c b/lib/memtypes.c
index cd39c99..766f487 100644
--- a/lib/memtypes.c
+++ b/lib/memtypes.c
@@ -178,6 +178,7 @@ struct memory_list memory_list_babel[] =
 {
   { MTYPE_BABEL,              "Babel structure"			},
   { MTYPE_BABEL_IF,           "Babel interface"			},
+  { MTYPE_BABEL_AUTH,         "Babel authentication"		},
   { -1, NULL }
 };
 
